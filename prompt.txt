Path: C:\MyData\Flutter\flutter_application_1\lib\firebase_options.dart
Content:
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyDeAgGiF-M3Je4DUpKT59O_lvgB3uDUvik',
    appId: '1:851904795750:web:eb6f94b1e65288e42289a7',
    messagingSenderId: '851904795750',
    projectId: 'gold-silver-rates-app-by-gc',
    authDomain: 'gold-silver-rates-app-by-gc.firebaseapp.com',
    storageBucket: 'gold-silver-rates-app-by-gc.firebasestorage.app',
    measurementId: 'G-HDESC5F5Q3',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyBdsgaE-nyHdsk_XAUKf09Ck6xlxuKQLHs',
    appId: '1:851904795750:android:435dc3a51cadc5892289a7',
    messagingSenderId: '851904795750',
    projectId: 'gold-silver-rates-app-by-gc',
    storageBucket: 'gold-silver-rates-app-by-gc.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCs4eU8OcoS1AwRLmrqsQVUSg5UwODXbqI',
    appId: '1:851904795750:ios:f7e56d4344795c172289a7',
    messagingSenderId: '851904795750',
    projectId: 'gold-silver-rates-app-by-gc',
    storageBucket: 'gold-silver-rates-app-by-gc.firebasestorage.app',
    iosBundleId: 'com.example.gcGoldRates',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyCs4eU8OcoS1AwRLmrqsQVUSg5UwODXbqI',
    appId: '1:851904795750:ios:f7e56d4344795c172289a7',
    messagingSenderId: '851904795750',
    projectId: 'gold-silver-rates-app-by-gc',
    storageBucket: 'gold-silver-rates-app-by-gc.firebasestorage.app',
    iosBundleId: 'com.example.gcGoldRates',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyDeAgGiF-M3Je4DUpKT59O_lvgB3uDUvik',
    appId: '1:851904795750:web:8015c6a212adea922289a7',
    messagingSenderId: '851904795750',
    projectId: 'gold-silver-rates-app-by-gc',
    authDomain: 'gold-silver-rates-app-by-gc.firebaseapp.com',
    storageBucket: 'gold-silver-rates-app-by-gc.firebasestorage.app',
    measurementId: 'G-8R903EXBF4',
  );
}


Path: C:\MyData\Flutter\flutter_application_1\lib\main.dart
Content:
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:provider/provider.dart';

import 'providers/rates_provider.dart';
import 'providers/alert_provider.dart';
import 'providers/theme_provider.dart' as custom_theme;
import 'screens/initialization_screen.dart';

@pragma('vm:entry-point')
Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  await Firebase.initializeApp();
  print('Handling a background message: ${message.messageId}');
}

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp();

  FirebaseMessaging.onBackgroundMessage(firebaseMessagingBackgroundHandler);

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => custom_theme.ThemeProvider()),
        ChangeNotifierProvider(create: (_) => RatesProvider()),
        ChangeNotifierProvider(create: (_) => AlertProvider()),
      ],
      child: Consumer<custom_theme.ThemeProvider>(
        builder: (context, themeProvider, child) {
          return MaterialApp(
            title: 'GC Gold Rates',
            theme: themeProvider.lightTheme,
            darkTheme: themeProvider.darkTheme,
            themeMode:
                ThemeMode.values[custom_theme.AppThemeMode.values.indexOf(
                  themeProvider.themeMode,
                )],
            home: const InitializationScreen(),
            debugShowCheckedModeBanner: false,
          );
        },
      ),
    );
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\models\alert_model.dart
Content:
class RateAlert {
  final String id;
  final String rateType;
  final String conditionType;
  final double targetValue;
  final bool isActive;
  final DateTime createdAt;
  final DateTime? triggeredAt;

  RateAlert({
    required this.id,
    required this.rateType,
    required this.conditionType,
    required this.targetValue,
    required this.isActive,
    required this.createdAt,
    this.triggeredAt,
  });

  factory RateAlert.fromJson(Map<String, dynamic> json) {
    return RateAlert(
      id: json['id'].toString(),
      rateType: json['rate_type'] ?? '',
      conditionType: json['condition_type'] ?? '',
      targetValue: (json['target_value'] as num?)?.toDouble() ?? 0.0,
      isActive: json['is_active'] ?? true,
      createdAt: DateTime.parse(json['created_at']),
      triggeredAt: json['triggered_at'] != null 
          ? DateTime.parse(json['triggered_at']) 
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'rate_type': rateType,
      'condition_type': conditionType,
      'target_value': targetValue,
      'is_active': isActive,
      'created_at': createdAt.toIso8601String(),
      'triggered_at': triggeredAt?.toIso8601String(),
    };
  }

  RateAlert copyWith({
    String? id,
    String? rateType,
    String? conditionType,
    double? targetValue,
    bool? isActive,
    DateTime? createdAt,
    DateTime? triggeredAt,
  }) {
    return RateAlert(
      id: id ?? this.id,
      rateType: rateType ?? this.rateType,
      conditionType: conditionType ?? this.conditionType,
      targetValue: targetValue ?? this.targetValue,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      triggeredAt: triggeredAt ?? this.triggeredAt,
    );
  }

  String get displayCondition {
    return conditionType == 'above' ? 'Above' : 'Below';
  }

  String get rateDisplayName {
    switch (rateType) {
      case 'gold':
        return 'Gold 995';
      case 'goldfuture':
        return 'Gold Future';
      case 'silverfuture':
        return 'Silver Future';
      case 'dollarinr':
        return 'USD/INR';
      case 'golddollar':
        return 'Gold/USD';
      case 'silverdollar':
        return 'Silver/USD';
      case 'goldrefine':
        return 'Gold Refine';
      case 'goldrtgs':
        return 'Gold RTGS';
      default:
        return rateType.toUpperCase();
    }
  }

  bool checkCondition(double currentRate) {
    if (conditionType == 'above') {
      return currentRate > targetValue;
    } else {
      return currentRate < targetValue;
    }
  }
}

Path: C:\MyData\Flutter\flutter_application_1\lib\models\rate_card.dart
Content:
class RateCard {
  final int uniqueId;
  final String title;
  final String apiSymbol;
  String buyRate = "0.0";
  String sellRate = "0.0";
  String buyHigh = "0.0";
  String buyLow = "0.0";
  String sellHigh = "0.0";
  String sellLow = "0.0";
  String previousBuyRate = "0.0";
  String previousSellRate = "0.0";
  RateCard({
    required this.uniqueId,
    required this.title,
    required this.apiSymbol,
  });
}

Path: C:\MyData\Flutter\flutter_application_1\lib\providers\alert_provider.dart
Content:
import 'package:flutter/material.dart';
import '../models/alert_model.dart';
import '../services/alert_service.dart';
import 'dart:developer' as developer;

class AlertProvider with ChangeNotifier {
  final AlertService _alertService = AlertService();
  
  List<RateAlert> _alerts = [];
  bool _isLoading = false;
  String? _errorMessage;

  List<RateAlert> get alerts => List.unmodifiable(_alerts);
  bool get isLoading => _isLoading;
  String? get errorMessage => _errorMessage;

  List<RateAlert> get activeAlerts => 
      _alerts.where((alert) => alert.isActive).toList();

  Future<void> loadAlerts() async {
    _setLoading(true);
    _clearError();
    
    try {
      _alerts = await _alertService.getUserAlerts();
      developer.log('Loaded ${_alerts.length} alerts', name: 'AlertProvider');
    } catch (e) {
      _setError(e.toString());
      developer.log('Error loading alerts: $e', name: 'AlertProvider');
    } finally {
      _setLoading(false);
    }
  }

  Future<bool> createAlert({
    required String rateType,
    required String conditionType,
    required double targetValue,
  }) async {
    _clearError();
    
    if (_hasConflictingAlert(rateType, conditionType, targetValue)) {
      _setError('Similar alert already exists for this rate and condition');
      return false;
    }

    try {
      final newAlert = await _alertService.createAlert(
        rateType: rateType,
        conditionType: conditionType,
        targetValue: targetValue,
      );
      
      _alerts.add(newAlert);
      notifyListeners();
      
      developer.log('Created alert: ${newAlert.rateDisplayName} ${newAlert.displayCondition} ${newAlert.targetValue}', 
                   name: 'AlertProvider');
      return true;
    } catch (e) {
      _setError(e.toString());
      developer.log('Error creating alert: $e', name: 'AlertProvider');
      return false;
    }
  }

  Future<bool> deleteAlert(String alertId) async {
    _clearError();
    
    try {
      await _alertService.deleteAlert(alertId);
      _alerts.removeWhere((alert) => alert.id == alertId);
      notifyListeners();
      
      developer.log('Deleted alert: $alertId', name: 'AlertProvider');
      return true;
    } catch (e) {
      _setError(e.toString());
      developer.log('Error deleting alert: $e', name: 'AlertProvider');
      return false;
    }
  }

  Future<bool> toggleAlert(String alertId) async {
    _clearError();
    
    final alertIndex = _alerts.indexWhere((alert) => alert.id == alertId);
    if (alertIndex == -1) {
      _setError('Alert not found');
      return false;
    }

    final alert = _alerts[alertIndex];
    final newActiveState = !alert.isActive;

    try {
      await _alertService.updateAlert(alertId, isActive: newActiveState);
      _alerts[alertIndex] = alert.copyWith(isActive: newActiveState);
      notifyListeners();
      
      developer.log('Toggled alert $alertId to ${newActiveState ? "active" : "inactive"}', 
                   name: 'AlertProvider');
      return true;
    } catch (e) {
      _setError(e.toString());
      developer.log('Error toggling alert: $e', name: 'AlertProvider');
      return false;
    }
  }

  bool _hasConflictingAlert(String rateType, String conditionType, double targetValue) {
    return _alerts.any((alert) => 
        alert.rateType == rateType && 
        alert.conditionType == conditionType && 
        (alert.targetValue - targetValue).abs() < 0.01 &&
        alert.isActive);
  }

  int getAlertsCountForRate(String rateType) {
    return _alerts.where((alert) => 
        alert.rateType == rateType && alert.isActive).length;
  }

  List<RateAlert> getAlertsForRate(String rateType) {
    return _alerts.where((alert) => alert.rateType == rateType).toList();
  }

  void _setLoading(bool loading) {
    _isLoading = loading;
    notifyListeners();
  }

  void _setError(String error) {
    _errorMessage = error;
    notifyListeners();
  }

  void _clearError() {
    _errorMessage = null;
    notifyListeners();
  }

  void clearError() {
    _clearError();
  }

  Future<void> refreshAlerts() async {
    await loadAlerts();
  }
}

Path: C:\MyData\Flutter\flutter_application_1\lib\providers\rates_provider.dart
Content:
import 'dart:async';
import 'dart:developer' as developer;
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:home_widget/home_widget.dart';
import 'package:intl/intl.dart';
import '../models/rate_card.dart';
import '../services/api_service.dart';

void updateHomeWidget(RateCard? goldCard, RateCard? silverCard) {
  final formattedTime = DateFormat('hh:mm a').format(DateTime.now());
  HomeWidget.saveWidgetData<String>(
    'gold_rate',
    "₹ ${goldCard?.buyRate ?? '...'}",
  );
  HomeWidget.saveWidgetData<String>(
    'silver_rate',
    "₹ ${silverCard?.buyRate ?? '...'}",
  );
  HomeWidget.saveWidgetData<String>('widget_timestamp', formattedTime);
  HomeWidget.updateWidget(
    name: 'RatesWidgetProvider',
    androidName: 'RatesWidgetProvider',
    iOSName: 'RatesWidget',
  );
}

class RatesProvider with ChangeNotifier {
  final ApiService _apiService = ApiService();
  List<RateCard> rateCards = [];
  bool isLoading = false;
  String? errorMessage;
  Timer? _timer;
  bool _isInitialized = false;
  bool _disposed = false;

  final List<Map<String, dynamic>> _cardConfigs = [
    {'title': 'Gold 995', 'uniqueId': 0, 'apiSymbol': 'gold'},
    {'title': 'Gold Future', 'uniqueId': 2, 'apiSymbol': 'goldfuture'},
    {'title': 'Silver Future', 'uniqueId': 3, 'apiSymbol': 'silverfuture'},
    {'title': 'USD / INR', 'uniqueId': 4, 'apiSymbol': 'dollarinr'},
    {'title': 'Gold / USD', 'uniqueId': 5, 'apiSymbol': 'golddollar'},
    {'title': 'Silver / USD', 'uniqueId': 6, 'apiSymbol': 'silverdollar'},
    {'title': 'Gold / Refine', 'uniqueId': 7, 'apiSymbol': 'goldrefine'},
    {'title': 'Gold / RTGS', 'uniqueId': 8, 'apiSymbol': 'goldrtgs'},
  ];

  RatesProvider();

  Future<void> initializeAndFetch() async {
    if (_isInitialized || _disposed) return;

    try {
      await _initializeCards();
      startAutoRefresh();
      _isInitialized = true;
    } catch (e) {
      developer.log(
        'Error during initialization: $e',
        name: 'RatesProvider',
        error: e,
      );
      rethrow;
    }
  }

  Future<void> _initializeCards() async {
    if (_disposed) return;

    final prefs = await SharedPreferences.getInstance();
    List<String>? savedOrderIds = prefs.getStringList('cardOrder');
    List<int> order =
        savedOrderIds?.map(int.parse).toList() ??
        _cardConfigs.map<int>((c) => c['uniqueId']).toList();

    Map<int, Map<String, dynamic>> configMap = {
      for (var c in _cardConfigs) c['uniqueId']: c,
    };

    rateCards = order
        .map(
          (id) => RateCard(
            uniqueId: id,
            title: configMap[id]!['title'],
            apiSymbol: configMap[id]!['apiSymbol'],
          ),
        )
        .toList();

    await fetchRates();
  }

  Future<void> fetchRates() async {
    if (isLoading || _disposed) return;

    isLoading = true;
    if (rateCards.isNotEmpty &&
        rateCards.first.buyRate == "0.0" &&
        !_disposed) {
      notifyListeners();
    }

    try {
      final data = await _apiService.fetchLiveRates();
      if (_disposed) return;

      Map<String, dynamic>? ratesData;
      if (data.containsKey('rates') && data['rates'] is Map<String, dynamic>) {
        ratesData = data['rates'] as Map<String, dynamic>;
      } else if (data.isNotEmpty) {
        ratesData = data;
      }

      if (ratesData != null && !_disposed) {
        for (var card in rateCards) {
          if (ratesData.containsKey(card.apiSymbol)) {
            final rateInfo = ratesData[card.apiSymbol];
            card.previousBuyRate = card.buyRate;
            card.previousSellRate = card.sellRate;

            if (rateInfo != null) {
              if (rateInfo is Map<String, dynamic>) {
                card.buyRate = rateInfo['buy']?.toString() ?? "0.0";
                card.sellRate = rateInfo['sell']?.toString() ?? "0.0";
                
                if (rateInfo['high'] is Map<String, dynamic>) {
                  final highData = rateInfo['high'] as Map<String, dynamic>;
                  card.buyHigh = highData['buy']?.toString() ?? "0.0";
                  card.sellHigh = highData['sell']?.toString() ?? "0.0";
                } else {
                  card.buyHigh = rateInfo['high']?.toString() ?? "0.0";
                  card.sellHigh = rateInfo['high']?.toString() ?? "0.0";
                }
                
                if (rateInfo['low'] is Map<String, dynamic>) {
                  final lowData = rateInfo['low'] as Map<String, dynamic>;
                  card.buyLow = lowData['buy']?.toString() ?? "0.0";
                  card.sellLow = lowData['sell']?.toString() ?? "0.0";
                } else {
                  card.buyLow = rateInfo['low']?.toString() ?? "0.0";
                  card.sellLow = rateInfo['low']?.toString() ?? "0.0";
                }
              } else {
                final rateValue = rateInfo.toString();
                card.buyRate = rateValue;
                card.sellRate = rateValue;
                card.buyHigh = rateValue;
                card.sellHigh = rateValue;
                card.buyLow = rateValue;
                card.sellLow = rateValue;
              }
            }
          }
        }
        errorMessage = null;

        final goldCard = rateCards
            .where((card) => card.apiSymbol == 'gold')
            .firstOrNull;
        final silverCard = rateCards
            .where((card) => card.apiSymbol == 'silverfuture')
            .firstOrNull;
        updateHomeWidget(goldCard, silverCard);
      } else if (!_disposed) {
        throw Exception('Could not parse rates from the API response.');
      }
    } catch (e) {
      if (!_disposed) {
        errorMessage = e.toString();
        developer.log(
          'Error fetching rates: $e',
          name: 'RatesProvider',
          error: e,
        );
      }
    } finally {
      if (!_disposed) {
        isLoading = false;
        notifyListeners();
      }
    }
  }

  void startAutoRefresh() {
    if (_disposed) return;

    _timer?.cancel();
    _timer = Timer.periodic(const Duration(seconds: 30), (timer) {
      if (!_disposed) {
        fetchRates();
      } else {
        timer.cancel();
      }
    });
  }

  void stopAutoRefresh() {
    _timer?.cancel();
    _timer = null;
  }

  Future<void> reorderCards(int oldIndex, int newIndex) async {
    if (_disposed) return;

    if (oldIndex < newIndex) {
      newIndex -= 1;
    }

    final RateCard item = rateCards.removeAt(oldIndex);
    rateCards.insert(newIndex, item);

    try {
      final prefs = await SharedPreferences.getInstance();
      List<String> newOrderIds = rateCards
          .map((c) => c.uniqueId.toString())
          .toList();
      await prefs.setStringList('cardOrder', newOrderIds);

      if (!_disposed) {
        notifyListeners();
      }
    } catch (e) {
      developer.log(
        'Error saving card order: $e',
        name: 'RatesProvider',
        error: e,
      );
    }
  }

  @override
  void notifyListeners() {
    if (!_disposed) {
      super.notifyListeners();
    }
  }

  @override
  void dispose() {
    _disposed = true;
    _timer?.cancel();
    _timer = null;
    super.dispose();
  }
}

Path: C:\MyData\Flutter\flutter_application_1\lib\screens\alert_creation_screen.dart
Content:
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import '../providers/alert_provider.dart';
import '../providers/rates_provider.dart';
import '../services/alert_service.dart';

class AlertCreationScreen extends StatefulWidget {
  final String? initialRateType;

  const AlertCreationScreen({super.key, this.initialRateType});

  @override
  State<AlertCreationScreen> createState() => _AlertCreationScreenState();
}

class _AlertCreationScreenState extends State<AlertCreationScreen> {
  final _formKey = GlobalKey<FormState>();
  final _targetValueController = TextEditingController();

  String _selectedRateType = 'gold';
  String _selectedCondition = 'above';
  bool _isCreating = false;
  bool _isTestingConnection = false;
  bool? _connectionStatus;

  final List<Map<String, String>> _rateOptions = [
    {'value': 'gold', 'label': 'Gold 995'},
    {'value': 'goldfuture', 'label': 'Gold Future'},
    {'value': 'silverfuture', 'label': 'Silver Future'},
    {'value': 'dollarinr', 'label': 'USD/INR'},
    {'value': 'golddollar', 'label': 'Gold/USD'},
    {'value': 'silverdollar', 'label': 'Silver/USD'},
    {'value': 'goldrefine', 'label': 'Gold Refine'},
    {'value': 'goldrtgs', 'label': 'Gold RTGS'},
  ];

  @override
  void initState() {
    super.initState();
    if (widget.initialRateType != null &&
        _rateOptions.any((o) => o['value'] == widget.initialRateType)) {
      _selectedRateType = widget.initialRateType!;
    }
    _testConnection();
  }

  @override
  void dispose() {
    _targetValueController.dispose();
    super.dispose();
  }

  double? _getCurrentRate() {
    final ratesProvider = context.read<RatesProvider>();
    final rateCard = ratesProvider.rateCards.firstWhere(
      (card) => card.apiSymbol == _selectedRateType,
      orElse: () => null as dynamic,
    );
    if (rateCard != null) {
      return double.tryParse(rateCard.buyRate);
    }
    return null;
  }

  Future<void> _testConnection() async {
    setState(() => _isTestingConnection = true);
    try {
      final alertService = AlertService();
      final isConnected = await alertService.testConnection();
      if (mounted) {
        setState(() {
          _connectionStatus = isConnected;
          _isTestingConnection = false;
        });
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Row(
              children: [
                Icon(
                  isConnected ? Icons.check_circle : Icons.error,
                  color: Theme.of(context).colorScheme.onPrimary,
                  size: 20,
                ),
                const SizedBox(width: 8),
                Text(
                  isConnected
                      ? 'Server Connected ✅'
                      : 'Server Connection Failed ❌',
                ),
              ],
            ),
            backgroundColor: isConnected
                ? Theme.of(context).colorScheme.secondary
                : Theme.of(context).colorScheme.error,
            duration: const Duration(seconds: 3),
          ),
        );
      }
    } catch (_) {
      if (mounted) {
        setState(() {
          _connectionStatus = false;
          _isTestingConnection = false;
        });
      }
    }
  }

  Future<void> _createAlert() async {
    if (_connectionStatus != true) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('Cannot create alert: Server connection failed'),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
      return;
    }
    if (!_formKey.currentState!.validate()) return;
    setState(() => _isCreating = true);
    final targetValue = double.parse(_targetValueController.text);
    final success = await context.read<AlertProvider>().createAlert(
      rateType: _selectedRateType,
      conditionType: _selectedCondition,
      targetValue: targetValue,
    );
    setState(() => _isCreating = false);
    if (!mounted) return;
    if (success) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: const Text('Alert created successfully!'),
          backgroundColor: Theme.of(context).colorScheme.secondary,
        ),
      );
      Navigator.of(context).pop();
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            context.read<AlertProvider>().errorMessage ??
                'Failed to create alert',
          ),
          backgroundColor: Theme.of(context).colorScheme.error,
        ),
      );
    }
  }

  void _fillCurrentRate() {
    final currentRate = _getCurrentRate();
    if (currentRate != null) {
      _targetValueController.text = currentRate.toStringAsFixed(2);
    }
  }

  Widget _buildConnectionStatus() {
    final cs = Theme.of(context).colorScheme;
    if (_isTestingConnection) {
      return Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: cs.primaryContainer.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: cs.primaryContainer),
        ),
        child: const Row(
          children: [
            SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2),
            ),
            SizedBox(width: 12),
            Text('Testing server connection...'),
          ],
        ),
      );
    }
    if (_connectionStatus == null) return const SizedBox.shrink();
    final success = _connectionStatus!;
    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: success ? cs.secondaryContainer : cs.errorContainer,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: success ? cs.secondary : cs.error),
      ),
      child: Row(
        children: [
          Icon(
            success ? Icons.check_circle : Icons.error,
            color: success ? cs.secondary : cs.error,
            size: 20,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              success
                  ? 'Server connected - Alerts will work properly'
                  : 'Server connection failed - Alerts may not work',
              style: TextStyle(
                color: success ? cs.secondary : cs.error,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
          TextButton(onPressed: _testConnection, child: const Text('Retry')),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final currentRate = _getCurrentRate();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Create Price Alert'),
        backgroundColor: theme.colorScheme.primary,
        foregroundColor: theme.colorScheme.onPrimary,
        elevation: 0,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _testConnection,
            tooltip: 'Test Server Connection',
          ),
        ],
      ),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(16.0),
          children: [
            // Connection Status Card
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                          Icons.cloud,
                          color: theme.colorScheme.primary,
                          size: 20,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          'Server Status',
                          style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    _buildConnectionStatus(),
                  ],
                ),
              ),
            ),

            const SizedBox(height: 16),

            // Alert Configuration
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'Alert Configuration',
                      style: theme.textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 20),

                    // Rate Type Dropdown
                    DropdownButtonFormField<String>(
                      value: _selectedRateType,
                      decoration: InputDecoration(
                        labelText: 'Select Rate Type',
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                        prefixIcon: const Icon(Icons.trending_up),
                      ),
                      items: _rateOptions.map((option) {
                        return DropdownMenuItem(
                          value: option['value'],
                          child: Text(option['label']!),
                        );
                      }).toList(),
                      onChanged: (value) {
                        if (value != null) {
                          setState(() => _selectedRateType = value);
                        }
                      },
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please select a rate type';
                        }
                        return null;
                      },
                    ),

                    const SizedBox(height: 16),

                    // Condition Dropdown
                    DropdownButtonFormField<String>(
                      value: _selectedCondition,
                      decoration: InputDecoration(
                        labelText: 'Condition',
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                        prefixIcon: const Icon(Icons.compare_arrows),
                      ),
                      items: [
                        DropdownMenuItem(
                          value: 'above',
                          child: Row(
                            children: [
                              Icon(
                                Icons.keyboard_arrow_up,
                                color: theme.colorScheme.secondary,
                              ),
                              const SizedBox(width: 8),
                              const Text('Above'),
                            ],
                          ),
                        ),
                        DropdownMenuItem(
                          value: 'below',
                          child: Row(
                            children: [
                              Icon(
                                Icons.keyboard_arrow_down,
                                color: theme.colorScheme.error,
                              ),
                              const SizedBox(width: 8),
                              const Text('Below'),
                            ],
                          ),
                        ),
                      ],
                      onChanged: (value) {
                        if (value != null) {
                          setState(() => _selectedCondition = value);
                        }
                      },
                    ),

                    const SizedBox(height: 16),

                    // Target Price Field
                    TextFormField(
                      controller: _targetValueController,
                      decoration: InputDecoration(
                        labelText: 'Target Price (₹)',
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                        prefixIcon: const Icon(Icons.currency_rupee),
                        suffixIcon: currentRate != null
                            ? IconButton(
                                icon: const Icon(Icons.refresh),
                                onPressed: _fillCurrentRate,
                                tooltip: 'Use current rate',
                              )
                            : null,
                      ),
                      keyboardType: const TextInputType.numberWithOptions(
                        decimal: true,
                      ),
                      inputFormatters: [
                        FilteringTextInputFormatter.allow(
                          RegExp(r'^\d*\.?\d{0,2}'),
                        ),
                      ],
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return 'Please enter a target price';
                        }
                        final double? price = double.tryParse(value);
                        if (price == null || price <= 0) {
                          return 'Please enter a valid price';
                        }
                        return null;
                      },
                    ),

                    if (currentRate != null) ...[
                      const SizedBox(height: 12),
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: theme.colorScheme.primaryContainer.withOpacity(
                            0.3,
                          ),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        child: Row(
                          children: [
                            Icon(
                              Icons.info_outline,
                              color: theme.colorScheme.primary,
                              size: 20,
                            ),
                            const SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                'Current rate: ₹${currentRate.toStringAsFixed(2)}',
                                style: TextStyle(
                                  color: theme.colorScheme.primary,
                                  fontWeight: FontWeight.w500,
                                ),
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),

            const SizedBox(height: 20),

            // Create Button
            ElevatedButton(
              onPressed: (_isCreating || _connectionStatus != true)
                  ? null
                  : _createAlert,
              style: ElevatedButton.styleFrom(
                backgroundColor: theme.colorScheme.primary,
                foregroundColor: theme.colorScheme.onPrimary,
                padding: const EdgeInsets.symmetric(vertical: 16),
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12),
                ),
              ),
              child: _isCreating
                  ? SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(
                          theme.colorScheme.onPrimary,
                        ),
                      ),
                    )
                  : Text(
                      _connectionStatus == true
                          ? 'Create Alert'
                          : 'Server Connection Required',
                      style: const TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
            ),

            const SizedBox(height: 16),

            // How Alerts Work
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Icon(
                          Icons.info_outline,
                          color: theme.colorScheme.primary,
                          size: 20,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          'How Alerts Work',
                          style: theme.textTheme.titleMedium?.copyWith(
                            fontWeight: FontWeight.bold,
                            color: theme.colorScheme.primary,
                          ),
                        ),
                      ],
                    ),
                    const SizedBox(height: 12),
                    const Text(
                      '• Alerts are monitored 24/7 on our servers\n'
                      '• You\'ll receive push notifications when conditions are met\n'
                      '• Alerts work even when the app is closed\n'
                      '• No impact on your device\'s battery life\n'
                      '• You can manage alerts anytime from the Alerts tab',
                      style: TextStyle(height: 1.5),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\screens\alert_management_screen.dart
Content:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/alert_provider.dart';
import '../models/alert_model.dart';
import 'alert_creation_screen.dart';

class AlertManagementScreen extends StatefulWidget {
  const AlertManagementScreen({Key? key}) : super(key: key);

  @override
  State<AlertManagementScreen> createState() => _AlertManagementScreenState();
}

class _AlertManagementScreenState extends State<AlertManagementScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<AlertProvider>().loadAlerts();
    });
  }

  Future<void> _refreshAlerts() async {
    await context.read<AlertProvider>().refreshAlerts();
  }

  void _confirmDelete(RateAlert alert) {
    final colors = Theme.of(context).colorScheme;
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Delete Alert'),
        content: Text(
          'Delete alert for ${alert.rateDisplayName} '
          '${alert.displayCondition.toLowerCase()} '
          '₹${alert.targetValue.toStringAsFixed(2)}?',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () async {
              Navigator.of(ctx).pop();
              final success = await context.read<AlertProvider>().deleteAlert(
                alert.id,
              );
              if (mounted && success) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: const Text('Alert deleted'),
                    backgroundColor: colors.secondary,
                  ),
                );
              }
            },
            style: TextButton.styleFrom(foregroundColor: colors.error),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colors = theme.colorScheme;

    return Scaffold(
      body: RefreshIndicator(
        onRefresh: _refreshAlerts,
        child: Consumer<AlertProvider>(
          builder: (ctx, provider, _) {
            if (provider.isLoading && provider.alerts.isEmpty) {
              return const Center(child: CircularProgressIndicator());
            }
            if (provider.errorMessage != null) {
              return _buildError(theme, provider.errorMessage!);
            }
            if (provider.alerts.isEmpty) {
              return _buildEmpty(theme);
            }
            return _buildList(theme, provider.alerts);
          },
        ),
      ),
      floatingActionButton: FloatingActionButton(
        backgroundColor: colors.secondary,
        foregroundColor: colors.onSecondary,
        onPressed: () => Navigator.of(
          context,
        ).push(MaterialPageRoute(builder: (_) => const AlertCreationScreen())),
        child: const Icon(Icons.add),
      ),
    );
  }

  Widget _buildError(ThemeData theme, String error) {
    final colors = theme.colorScheme;
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline, size: 60, color: colors.error),
            const SizedBox(height: 16),
            Text(
              'Error Loading Alerts',
              style: theme.textTheme.headlineSmall,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              error,
              style: theme.textTheme.bodyMedium,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              style: ElevatedButton.styleFrom(
                backgroundColor: colors.primary,
                foregroundColor: colors.onPrimary,
              ),
              onPressed: _refreshAlerts,
              icon: const Icon(Icons.refresh),
              label: const Text('Retry'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildEmpty(ThemeData theme) {
    final colors = theme.colorScheme;
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.notifications_none,
              size: 80,
              color: colors.onSurfaceVariant,
            ),
            const SizedBox(height: 24),
            Text(
              'No Price Alerts',
              style: theme.textTheme.headlineSmall?.copyWith(
                color: colors.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 12),
            Text(
              'Create your first alert to get notified when '
              'prices reach your targets.',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colors.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 32),
            ElevatedButton.icon(
              style: ElevatedButton.styleFrom(
                backgroundColor: colors.primary,
                foregroundColor: colors.onPrimary,
              ),
              onPressed: () => Navigator.of(context).push(
                MaterialPageRoute(builder: (_) => const AlertCreationScreen()),
              ),
              icon: const Icon(Icons.add),
              label: const Text('Create Alert'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildList(ThemeData theme, List<RateAlert> alerts) {
    final colors = theme.colorScheme;
    final active = alerts.where((a) => a.isActive).toList();
    final inactive = alerts.where((a) => !a.isActive).toList();

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        if (active.isNotEmpty) ...[
          _section(theme, 'Active Alerts', active.length),
          const SizedBox(height: 8),
          ...active.map((a) => _card(theme, a)),
          const SizedBox(height: 24),
        ],
        if (inactive.isNotEmpty) ...[
          _section(theme, 'Inactive Alerts', inactive.length),
          const SizedBox(height: 8),
          ...inactive.map((a) => _card(theme, a)),
        ],
      ],
    );
  }

  Widget _section(ThemeData theme, String title, int count) {
    final colors = theme.colorScheme;
    return Row(
      children: [
        Text(
          title,
          style: theme.textTheme.titleMedium?.copyWith(
            fontWeight: FontWeight.bold,
            color: colors.onSurface,
          ),
        ),
        const SizedBox(width: 8),
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: colors.secondaryContainer,
            borderRadius: BorderRadius.circular(12),
          ),
          child: Text(
            '$count',
            style: theme.textTheme.bodySmall?.copyWith(
              fontWeight: FontWeight.bold,
              color: colors.onSecondaryContainer,
            ),
          ),
        ),
      ],
    );
  }

  Widget _card(ThemeData theme, RateAlert alert) {
    final colors = theme.colorScheme;
    final fmt = NumberFormat.currency(
      locale: 'en_IN',
      symbol: '₹ ',
      decimalDigits: 2,
    );
    final df = DateFormat('dd MMM yyyy, hh:mm a');

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: alert.isActive ? 2 : 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: alert.isActive ? colors.primaryContainer : colors.outline,
          width: 1,
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        alert.rateDisplayName,
                        style: theme.textTheme.titleMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(
                            alert.conditionType == 'above'
                                ? Icons.keyboard_arrow_up
                                : Icons.keyboard_arrow_down,
                            color: alert.conditionType == 'above'
                                ? Colors.green
                                : colors.error,
                            size: 20,
                          ),
                          const SizedBox(width: 4),
                          Text(
                            '${alert.displayCondition} '
                            '${fmt.format(alert.targetValue)}',
                            style: theme.textTheme.bodyLarge?.copyWith(
                              fontWeight: FontWeight.w600,
                              color: alert.conditionType == 'above'
                                  ? Colors.green
                                  : colors.error,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                Switch(
                  value: alert.isActive,
                  activeColor: colors.primary, // thumb color when ON
                  activeTrackColor:
                      colors.primaryContainer, // track color when ON
                  inactiveThumbColor:
                      colors.onSurfaceVariant, // thumb color when OFF
                  inactiveTrackColor: colors.onSurfaceVariant.withOpacity(
                    0.3,
                  ), // track color when OFF
                  onChanged: (val) async {
                    final ok = await context.read<AlertProvider>().toggleAlert(
                      alert.id,
                    );
                    if (!ok && mounted) {
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(
                          content: Text(
                            context.read<AlertProvider>().errorMessage ??
                                'Update failed',
                          ),
                          backgroundColor: colors.error,
                        ),
                      );
                    }
                  },
                ),
              ],
            ),
            const SizedBox(height: 12),
            Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        'Created: ${df.format(alert.createdAt)}',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colors.onSurfaceVariant,
                        ),
                      ),
                      if (alert.triggeredAt != null) ...[
                        const SizedBox(height: 2),
                        Text(
                          'Triggered: ${df.format(alert.triggeredAt!)}',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: colors.secondary,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
                IconButton(
                  onPressed: () => _confirmDelete(alert),
                  icon: const Icon(Icons.delete_outline),
                  color: colors.error,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\screens\graphs_screen.dart
Content:
import 'dart:async';
import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:syncfusion_flutter_charts/charts.dart';
import '../services/api_service.dart';
import 'dart:developer' as developer;

const Map<String, int> _seriesIndexMap = {
  'golddollar': 0,
  'silverdollar': 1,
  'dollarinr': 2,
  'goldfuture': 3,
  'silverfuture': 4,
  'gold': 5,
  'goldrefine': 6,
  'goldrtgs': 7,
};

class GraphsScreen extends StatefulWidget {
  final String? initialSeriesSymbol;
  const GraphsScreen({super.key, this.initialSeriesSymbol});
  @override
  State<GraphsScreen> createState() => _GraphsScreenState();
}

enum TimeRange { day, week, month, year, custom }

class _ChartData {
  _ChartData(this.x, this.y);
  final DateTime x;
  final double y;
}

class _GraphsScreenState extends State<GraphsScreen> {
  bool _isLoading = true;
  String? _error;
  ApiResponse? _apiResponse;
  late String _selectedSeries;
  bool _isBuySelected = true;
  TimeRange _selectedTimeRange = TimeRange.day;
  DateTime? _customStartDate;
  DateTime? _customEndDate;
  final ApiService _apiService = ApiService();
  late ZoomPanBehavior _zoomPanBehavior;
  bool _disposed = false;

  final List<String> _seriesOptions = const [
    "gold",
    "goldfuture",
    "silverfuture",
    "dollarinr",
    "golddollar",
    "silverdollar",
    "goldrefine",
    "goldrtgs",
  ];

  @override
  void initState() {
    super.initState();
    _selectedSeries = widget.initialSeriesSymbol ?? _seriesOptions[0];
    if (!_seriesOptions.contains(_selectedSeries)) {
      _selectedSeries = _seriesOptions[0];
    }
    _zoomPanBehavior = ZoomPanBehavior(
      enablePinching: true,
      enablePanning: false,
      enableSelectionZooming: false,
      enableMouseWheelZooming: true,
      enableDoubleTapZooming: true,
    );
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted && !_disposed) {
        _fetchData();
      }
    });
  }

  @override
  void didUpdateWidget(covariant GraphsScreen oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.initialSeriesSymbol != null &&
        widget.initialSeriesSymbol != oldWidget.initialSeriesSymbol) {
      _selectedSeries = widget.initialSeriesSymbol!;
      _fetchData();
    }
  }

  @override
  void dispose() {
    _disposed = true;
    super.dispose();
  }

  Future<void> _fetchData() async {
    if (_disposed || !mounted) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final queryParams = _buildApiQuery();
      final data = await _apiService.fetchGraphData(
        _selectedSeries,
        queryParams,
      );

      if (_disposed || !mounted) return;

      setState(() {
        _apiResponse = ApiResponse.fromJson(data, _selectedSeries);
        _isLoading = false;
      });
    } catch (e, stacktrace) {
      developer.log(
        'Error in _fetchData: $e',
        name: 'GraphsScreen',
        error: e,
        stackTrace: stacktrace,
      );

      if (_disposed || !mounted) return;

      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  String _buildApiQuery() {
    final sdf = DateFormat('yyyy-MM-dd');
    String startDate, endDate, resolution;
    if (_selectedTimeRange == TimeRange.custom &&
        _customStartDate != null &&
        _customEndDate != null) {
      startDate = sdf.format(_customStartDate!);
      endDate = sdf.format(_customEndDate!);
      resolution = 'hour';
    } else {
      final now = DateTime.now();
      endDate = sdf.format(now);
      DateTime startDateTime;
      switch (_selectedTimeRange) {
        case TimeRange.day:
          startDateTime = now.subtract(const Duration(days: 1));
          resolution = '15min';
          break;
        case TimeRange.week:
          startDateTime = now.subtract(const Duration(days: 7));
          resolution = 'hour';
          break;
        case TimeRange.month:
          startDateTime = now.subtract(const Duration(days: 30));
          resolution = '4hour';
          break;
        case TimeRange.year:
          startDateTime = now.subtract(const Duration(days: 365));
          resolution = 'week';
          break;
        case TimeRange.custom:
          startDateTime = now.subtract(const Duration(days: 7));
          resolution = 'hour';
          break;
      }
      startDate = sdf.format(startDateTime);
    }
    return '?startDate=$startDate&endDate=$endDate&resolution=$resolution';
  }

  void _safeSetState(VoidCallback fn) {
    if (mounted && !_disposed) {
      setState(fn);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_disposed) {
      return const SizedBox.shrink();
    }

    return Scaffold(
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          _buildSeriesSelector(),
          const SizedBox(height: 16),
          _buildBuySellToggle(),
          const SizedBox(height: 16),
          _buildTimeRangeToggle(),
          const SizedBox(height: 20),
          _buildHighLowDisplay(),
          const SizedBox(height: 8),
          _buildChartContainer(),
        ],
      ),
    );
  }

  Widget _buildSeriesSelector() {
    return DropdownButtonFormField<String>(
      value: _selectedSeries,
      decoration: InputDecoration(
        labelText: 'Select Commodity',
        border: OutlineInputBorder(borderRadius: BorderRadius.circular(12)),
        filled: true,
        fillColor: Theme.of(context).colorScheme.surface.withOpacity(0.5),
      ),
      items: _seriesOptions.map((series) {
        return DropdownMenuItem(
          value: series,
          child: Text(series.toUpperCase()),
        );
      }).toList(),
      onChanged: (value) {
        if (value != null && mounted && !_disposed) {
          _safeSetState(() => _selectedSeries = value);
          _fetchData();
        }
      },
    );
  }

  Widget _buildBuySellToggle() {
    final theme = Theme.of(context);
    return Center(
      child: ToggleButtons(
        isSelected: [_isBuySelected, !_isBuySelected],
        onPressed: (index) {
          if (!_disposed &&
              mounted &&
              ((index == 0 && !_isBuySelected) ||
                  (index == 1 && _isBuySelected))) {
            _safeSetState(() => _isBuySelected = index == 0);
          }
        },
        borderRadius: BorderRadius.circular(12),
        selectedBorderColor: theme.colorScheme.primary,
        selectedColor: theme.colorScheme.onPrimary,
        fillColor: theme.colorScheme.primary,
        color: theme.colorScheme.onSurface,
        constraints: const BoxConstraints(minHeight: 44.0, minWidth: 120.0),
        children: const [
          Padding(
            padding: EdgeInsets.symmetric(horizontal: 16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.trending_up),
                SizedBox(width: 8),
                Text('BUY'),
              ],
            ),
          ),
          Padding(
            padding: EdgeInsets.symmetric(horizontal: 16.0),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(Icons.trending_down),
                SizedBox(width: 8),
                Text('SELL'),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTimeRangeToggle() {
    final theme = Theme.of(context);
    return Center(
      child: SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: ToggleButtons(
          isSelected: TimeRange.values
              .map((range) => _selectedTimeRange == range)
              .toList(),
          onPressed: (index) {
            if (_disposed || !mounted) return;

            final selectedRange = TimeRange.values[index];
            if (selectedRange == TimeRange.custom) {
              _showCustomDatePicker();
            } else {
              _safeSetState(() => _selectedTimeRange = selectedRange);
              _fetchData();
            }
          },
          borderRadius: BorderRadius.circular(12),
          selectedBorderColor: theme.colorScheme.primary,
          selectedColor: theme.colorScheme.onPrimary,
          fillColor: theme.colorScheme.primary.withOpacity(0.8),
          color: theme.colorScheme.onSurface,
          constraints: const BoxConstraints(minHeight: 40.0),
          children: TimeRange.values
              .map(
                (range) => Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 14),
                  child: Text(range.name.toUpperCase()),
                ),
              )
              .toList(),
        ),
      ),
    );
  }

  void _showCustomDatePicker() async {
    if (_disposed || !mounted) return;

    final now = DateTime.now();
    final pickedStartDate = await showDatePicker(
      context: context,
      initialDate: _customStartDate ?? now.subtract(const Duration(days: 7)),
      firstDate: DateTime(2020),
      lastDate: now,
    );

    if (pickedStartDate == null || _disposed || !mounted) return;

    final pickedEndDate = await showDatePicker(
      context: context,
      initialDate: _customEndDate ?? now,
      firstDate: pickedStartDate,
      lastDate: now,
    );

    if (pickedEndDate == null || _disposed || !mounted) return;

    _safeSetState(() {
      _selectedTimeRange = TimeRange.custom;
      _customStartDate = pickedStartDate;
      _customEndDate = pickedEndDate.add(const Duration(days: 1));
    });
    _fetchData();
  }

  Widget _buildHighLowDisplay() {
    if (_apiResponse?.stats == null || _disposed)
      return const SizedBox.shrink();
    final stats = _apiResponse!.stats!;
    final price = _isBuySelected ? stats.buy : stats.sell;
    final formatter = NumberFormat.currency(
      locale: 'en_IN',
      symbol: '₹ ',
      decimalDigits: 2,
    );
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceAround,
      children: [
        _buildStatPill('Lowest', formatter.format(price.low), Colors.red),
        _buildStatPill('Highest', formatter.format(price.high), Colors.green),
      ],
    );
  }

  Widget _buildStatPill(String label, String value, Color color) {
    final textTheme = Theme.of(context).textTheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: color.withOpacity(0.1),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: color.withOpacity(0.5)),
      ),
      child: Column(
        children: [
          Text(label, style: textTheme.labelMedium?.copyWith(color: color)),
          const SizedBox(height: 2),
          Text(
            value,
            style: textTheme.titleSmall?.copyWith(
              color: color,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildChartContainer() {
    return Card(
      elevation: 4,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
      color: Theme.of(context).colorScheme.surface.withOpacity(0.7),
      child: Padding(
        padding: const EdgeInsets.fromLTRB(8, 24, 16, 12),
        child: SizedBox(
          height: 320,
          child: _isLoading
              ? const Center(child: CircularProgressIndicator())
              : _error != null
              ? Center(
                  child: Padding(
                    padding: const EdgeInsets.all(12.0),
                    child: Text(
                      'An error occurred:\n$_error',
                      textAlign: TextAlign.center,
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.error,
                      ),
                    ),
                  ),
                )
              : _getChartData().isEmpty
              ? const Center(child: Text('No data available for this range.'))
              : _buildChart(),
        ),
      ),
    );
  }

  Widget _buildChart() {
    if (_disposed) return const SizedBox.shrink();

    return SfCartesianChart(
      primaryXAxis: DateTimeAxis(
        edgeLabelPlacement: EdgeLabelPlacement.shift,
        dateFormat: _getDateFormat(),
        intervalType: _getIntervalType(),
      ),
      primaryYAxis: NumericAxis(
        numberFormat: NumberFormat.compactCurrency(
          locale: 'en_IN',
          symbol: '₹',
        ),
        majorGridLines: const MajorGridLines(width: 0.5),
      ),
      series: <LineSeries<_ChartData, DateTime>>[
        LineSeries<_ChartData, DateTime>(
          dataSource: _getChartData(),
          xValueMapper: (_ChartData data, _) => data.x,
          yValueMapper: (_ChartData data, _) => data.y,
          name: _selectedSeries.toUpperCase(),
          color: Theme.of(context).colorScheme.primary,
          width: 2.5,
        ),
      ],
      zoomPanBehavior: _zoomPanBehavior,
      trackballBehavior: TrackballBehavior(
        enable: true,
        activationMode: ActivationMode.singleTap,
        lineType: TrackballLineType.vertical,
        lineColor: Theme.of(context).colorScheme.primary,
        lineWidth: 2,
        markerSettings: const TrackballMarkerSettings(
          markerVisibility: TrackballVisibilityMode.visible,
          height: 8,
          width: 8,
          borderWidth: 2,
        ),
        tooltipSettings: const InteractiveTooltip(enable: false),
        builder: (BuildContext context, TrackballDetails trackballDetails) {
          final point = trackballDetails.point;

          if (point == null || point.y == null) {
            return const SizedBox.shrink();
          }

          final currencyFormatter = NumberFormat.currency(
            locale: 'en_IN',
            symbol: '₹ ',
            decimalDigits: 2,
          );
          final String formattedRate = currencyFormatter.format(point.y);
          final String formattedDate = DateFormat(
            'dd MMM, hh:mm a',
          ).format(point.x as DateTime);

          return Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            decoration: BoxDecoration(
              color: Theme.of(context).colorScheme.secondary.withOpacity(0.8),
              borderRadius: BorderRadius.circular(8),
              boxShadow: [
                BoxShadow(
                  color: Theme.of(context).shadowColor,
                  blurRadius: 4,
                  offset: const Offset(0, 2),
                ),
              ],
            ),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  formattedRate,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSecondary,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 2),
                Text(
                  formattedDate,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSecondary,
                  ),
                ),
              ],
            ),
          );
        },
      ),
      onTrackballPositionChanging: (TrackballArgs args) {
        args.chartPointInfo.header = '';
      },
    );
  }

  List<_ChartData> _getChartData() {
    if (_apiResponse == null || _disposed) return [];
    final data = <_ChartData>[];
    for (final dataItem in _apiResponse!.data) {
      final value = _isBuySelected ? dataItem.buy : dataItem.sell;
      if (value > 0) {
        data.add(_ChartData(dataItem.createdAt, value));
      }
    }
    return data;
  }

  DateFormat _getDateFormat() {
    switch (_selectedTimeRange) {
      case TimeRange.day:
        return DateFormat.jm();
      case TimeRange.week:
      case TimeRange.month:
      case TimeRange.custom:
        return DateFormat('dd/MM');
      case TimeRange.year:
        return DateFormat('MMM yy');
    }
  }

  DateTimeIntervalType _getIntervalType() {
    switch (_selectedTimeRange) {
      case TimeRange.day:
        return DateTimeIntervalType.hours;
      case TimeRange.week:
        return DateTimeIntervalType.days;
      case TimeRange.month:
        return DateTimeIntervalType.days;
      case TimeRange.year:
        return DateTimeIntervalType.months;
      case TimeRange.custom:
        return DateTimeIntervalType.auto;
    }
  }
}

class ApiResponse {
  final List<DataItem> data;
  final Stats? stats;
  ApiResponse({required this.data, this.stats});
  factory ApiResponse.fromJson(Map<String, dynamic> json, String series) {
    Stats? seriesStats;
    if (json['stats'] != null &&
        json['stats'] is Map<String, dynamic> &&
        (json['stats'] as Map<String, dynamic>)[series] != null) {
      seriesStats = Stats.fromJson(
        (json['stats'] as Map<String, dynamic>)[series] as Map<String, dynamic>,
      );
    }
    List<DataItem> parsedData = [];
    if (json['data'] is List) {
      parsedData = (json['data'] as List<dynamic>)
          .map(
            (item) => DataItem.fromJson(item as Map<String, dynamic>, series),
          )
          .toList();
    }
    parsedData.sort((a, b) => a.createdAt.compareTo(b.createdAt));
    return ApiResponse(data: parsedData, stats: seriesStats);
  }
}

class DataItem {
  final double buy;
  final double sell;
  final DateTime createdAt;
  DataItem({required this.buy, required this.sell, required this.createdAt});
  factory DataItem.fromJson(Map<String, dynamic> json, String series) {
    double buy = 0.0;
    double sell = 0.0;
    if (json['data'] is String) {
      try {
        final List<dynamic> allSeriesData = jsonDecode(json['data']);
        final int? seriesIndex = _seriesIndexMap[series];
        if (seriesIndex != null && seriesIndex < allSeriesData.length) {
          final List<dynamic> specificSeriesData = allSeriesData[seriesIndex];
          if (specificSeriesData.length > 1) {
            buy = double.tryParse(specificSeriesData[0].toString()) ?? 0.0;
            sell = double.tryParse(specificSeriesData[1].toString()) ?? 0.0;
          }
        }
      } catch (e) {
        developer.log(
          'Error decoding DataItem data string: ${json['data']}',
          name: 'DataItem',
          error: e,
        );
      }
    }
    return DataItem(
      buy: buy,
      sell: sell,
      createdAt: DateTime.parse(json['createdAt']),
    );
  }
}

class Stats {
  final Price buy;
  final Price sell;
  Stats({required this.buy, required this.sell});
  factory Stats.fromJson(Map<String, dynamic> json) {
    return Stats(
      buy: json['buy'] != null
          ? Price.fromJson(json['buy'] as Map<String, dynamic>)
          : Price(high: 0, low: 0),
      sell: json['sell'] != null
          ? Price.fromJson(json['sell'] as Map<String, dynamic>)
          : Price(high: 0, low: 0),
    );
  }
}

class Price {
  final double high;
  final double low;
  Price({required this.high, required this.low});
  factory Price.fromJson(Map<String, dynamic> json) {
    return Price(
      high: (json['high'] as num?)?.toDouble() ?? 0.0,
      low: (json['low'] as num?)?.toDouble() ?? 0.0,
    );
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\screens\initialization_screen.dart
Content:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/rates_provider.dart';
import '../providers/theme_provider.dart' as custom_theme;
import '../services/notification_service.dart';
import '../widgets/cool_loader.dart';
import 'main_screen.dart';

class InitializationScreen extends StatefulWidget {
  const InitializationScreen({super.key});

  @override
  State<InitializationScreen> createState() => _InitializationScreenState();
}

class _InitializationScreenState extends State<InitializationScreen> {
  String? _error;

  @override
  void initState() {
    super.initState();
    _initializeApp();
  }

  Future<void> _initializeApp() async {
    if (!mounted) return;

    setState(() {
      _error = null;
    });

    try {
      // Initialize theme first
      final themeProvider = context.read<custom_theme.ThemeProvider>();
      await themeProvider.initializeTheme();

      // Initialize notifications
      await NotificationService().initNotifications();

      // Initialize and fetch rates
      if (mounted) {
        final ratesProvider = context.read<RatesProvider>();
        await ratesProvider.initializeAndFetch();
      }

      // Navigate to main screen
      if (mounted) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute(builder: (context) => const MainScreen()),
        );
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = e.toString();
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;

    return Scaffold(
      body: Center(
        child: _error == null
            ? const CoolLoader(
                loadingText: 'Loading GC Gold Rates...',
                size: 140.0,
              )
            : Padding(
                padding: const EdgeInsets.all(24.0),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.cloud_off_rounded,
                      size: 60,
                      color: colors.onSurfaceVariant,
                    ),
                    const SizedBox(height: 24),
                    Text(
                      'Connection Error',
                      style: Theme.of(context).textTheme.headlineSmall,
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 12),
                    Text(
                      _error ?? 'An unknown error occurred.',
                      textAlign: TextAlign.center,
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                    const SizedBox(height: 32),
                    ElevatedButton.icon(
                      onPressed: _initializeApp,
                      icon: const Icon(Icons.refresh),
                      label: const Text('Retry'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: colors.primary,
                        foregroundColor: colors.onPrimary,
                        padding: const EdgeInsets.symmetric(
                          horizontal: 24,
                          vertical: 12,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
      ),
    );
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\screens\main_screen.dart
Content:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:async';
import '../providers/rates_provider.dart';
import '../widgets/rate_card.dart';
import 'graphs_screen.dart';
import 'alert_management_screen.dart';
import 'settings_screen.dart';

class MainScreen extends StatefulWidget {
  const MainScreen({Key? key}) : super(key: key);

  @override
  MainScreenState createState() => MainScreenState();
}

class MainScreenState extends State<MainScreen>
    with TickerProviderStateMixin, WidgetsBindingObserver {
  int _currentIndex = 0;
  String _chartSeries = 'gold';
  late PageController _pageController;
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;
  Timer? _autoRefreshTimer;
  static const Duration _refreshInterval = Duration(seconds: 1);

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _pageController = PageController(initialPage: _currentIndex);
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 800),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeInOut),
    );
    _animationController.forward();
    _startAutoRefresh();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _stopAutoRefresh();
    _animationController.dispose();
    _pageController.dispose();
    super.dispose();
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.resumed) {
      _startAutoRefresh();
      _refreshRates();
    } else if (state == AppLifecycleState.paused) {
      _stopAutoRefresh();
    }
  }

  void _startAutoRefresh() {
    _stopAutoRefresh();
    _autoRefreshTimer = Timer.periodic(_refreshInterval, (_) {
      if (_currentIndex == 0 && mounted) _refreshRates();
    });
  }

  void _stopAutoRefresh() {
    _autoRefreshTimer?.cancel();
    _autoRefreshTimer = null;
  }

  void _refreshRates() {
    if (mounted) context.read<RatesProvider>().fetchRates();
  }

  /// Switch to Charts tab *and* set which series it should display.
  void switchToChartsTab(String series) {
    setState(() {
      _chartSeries = series;
      _currentIndex = 1;
    });
    _pageController.animateToPage(
      1,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
    _stopAutoRefresh();
  }

  void _onBottomNavTap(int index) {
    setState(() => _currentIndex = index);
    _pageController.animateToPage(
      index,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
    if (index == 0)
      _startAutoRefresh();
    else
      _stopAutoRefresh();
  }

  String _getAppBarTitle() {
    switch (_currentIndex) {
      case 0:
        return 'GC Gold Rates';
      case 1:
        return 'Charts';
      case 2:
        return 'Price Alerts';
      case 3:
        return 'Settings';
      default:
        return 'GC Gold Rates';
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colors = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: Text(_getAppBarTitle()),
        backgroundColor: theme.appBarTheme.backgroundColor,
        foregroundColor: theme.appBarTheme.foregroundColor,
        elevation: 0,
        automaticallyImplyLeading: false,
        actions: _currentIndex == 0
            ? [
                Consumer<RatesProvider>(
                  builder: (_, provider, __) {
                    return IconButton(
                      icon: provider.isLoading
                          ? SizedBox(
                              width: 20,
                              height: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: colors.onPrimary,
                              ),
                            )
                          : Icon(Icons.refresh, color: colors.onPrimary),
                      onPressed: provider.isLoading ? null : _refreshRates,
                    );
                  },
                ),
              ]
            : null,
      ),
      body: FadeTransition(
        opacity: _fadeAnimation,
        child: PageView(
          controller: _pageController,
          onPageChanged: (i) {
            setState(() => _currentIndex = i);
            if (i == 0)
              _startAutoRefresh();
            else
              _stopAutoRefresh();
          },
          children: [
            const _LiveRatesPage(),
            // pass our mutable chart symbol here
            GraphsScreen(initialSeriesSymbol: _chartSeries),
            const AlertManagementScreen(),
            const SettingsScreen(),
          ],
        ),
      ),
      bottomNavigationBar: BottomNavigationBar(
        type: BottomNavigationBarType.fixed,
        currentIndex: _currentIndex,
        onTap: _onBottomNavTap,
        selectedItemColor: colors.primary,
        unselectedItemColor: colors.onSurface.withOpacity(0.6),
        backgroundColor: colors.surface,
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.home_outlined),
            activeIcon: Icon(Icons.home),
            label: 'Rates',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.trending_up_outlined),
            activeIcon: Icon(Icons.trending_up),
            label: 'Charts',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.notifications_outlined),
            activeIcon: Icon(Icons.notifications),
            label: 'Alerts',
          ),
          BottomNavigationBarItem(
            icon: Icon(Icons.settings_outlined),
            activeIcon: Icon(Icons.settings),
            label: 'Settings',
          ),
        ],
      ),
    );
  }
}

class _LiveRatesPage extends StatelessWidget {
  const _LiveRatesPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    return RefreshIndicator(
      onRefresh: () async => context.read<RatesProvider>().fetchRates(),
      child: Consumer<RatesProvider>(
        builder: (_, provider, __) {
          if (provider.isLoading && provider.rateCards.isEmpty) {
            return const Center(child: CircularProgressIndicator());
          }
          if (provider.errorMessage != null) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text('Error: ${provider.errorMessage}'),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    style: ElevatedButton.styleFrom(
                      backgroundColor: colors.primary,
                      foregroundColor: colors.onPrimary,
                    ),
                    onPressed: () => context.read<RatesProvider>().fetchRates(),
                    child: const Text('Retry'),
                  ),
                ],
              ),
            );
          }
          if (provider.rateCards.isEmpty) {
            return const Center(child: Text('No rate cards available.'));
          }
          return ReorderableListView.builder(
            padding: const EdgeInsets.fromLTRB(8, 8, 8, 20),
            itemCount: provider.rateCards.length,
            itemBuilder: (_, index) {
              final card = provider.rateCards[index];
              return RateCardWidget(key: ValueKey(card.uniqueId), card: card);
            },
            onReorder: provider.reorderCards,
          );
        },
      ),
    );
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\screens\settings_screen.dart
Content:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/theme_provider.dart';
import '../widgets/theme_selection_dialog.dart';

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return ListView(
      padding: const EdgeInsets.all(16.0),
      children: [
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(Icons.palette_outlined, color: colors.primary),
                    const SizedBox(width: 12),
                    Text(
                      'Appearance',
                      style: textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                Consumer<ThemeProvider>(
                  builder: (_, themeProvider, __) {
                    String label;
                    IconData icon;
                    switch (themeProvider.themeMode) {
                      case AppThemeMode.light:
                        label = 'Light Theme';
                        icon = Icons.light_mode;
                        break;
                      case AppThemeMode.dark:
                        label = 'Dark Theme';
                        icon = Icons.dark_mode;
                        break;
                      case AppThemeMode.system:
                      default:
                        label = 'System Default';
                        icon = Icons.settings_brightness;
                        break;
                    }
                    return ListTile(
                      leading: Icon(icon),
                      title: const Text('Theme'),
                      subtitle: Text(label),
                      trailing: const Icon(Icons.chevron_right),
                      onTap: () => showDialog(
                        context: context,
                        builder: (_) => const ThemeSelectionDialog(),
                      ),
                    );
                  },
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 24),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Icon(Icons.info_outline, color: colors.primary),
                    const SizedBox(width: 12),
                    Text(
                      'About',
                      style: textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 16),
                ListTile(
                  leading: const Icon(Icons.apps),
                  title: const Text('App Version'),
                  subtitle: const Text('1.0.0'),
                ),
                ListTile(
                  leading: const Icon(Icons.business),
                  title: const Text('Developer'),
                  subtitle: const Text('GC Gold Rates Team'),
                ),
                ListTile(
                  leading: const Icon(Icons.description),
                  title: const Text('Privacy Policy'),
                  trailing: const Icon(Icons.launch),
                  onTap: () {},
                ),
                ListTile(
                  leading: const Icon(Icons.help_outline),
                  title: const Text('Help & Support'),
                  trailing: const Icon(Icons.launch),
                  onTap: () {},
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\services\alert_service.dart
Content:
import 'dart:async';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:firebase_messaging/firebase_messaging.dart';
import '../models/alert_model.dart';
import 'dart:developer' as developer;

class AlertService {
  static const String _baseUrl =
      "https://goldrate.divyanshbansal.com/api/alerts";
  final FirebaseMessaging _firebaseMessaging = FirebaseMessaging.instance;

  Future<String?> _getFcmToken() async {
    try {
      return await _firebaseMessaging.getToken();
    } catch (e) {
      developer.log('Error getting FCM token: $e', name: 'AlertService');
      return null;
    }
  }

  Future<RateAlert> createAlert({
    required String rateType,
    required String conditionType,
    required double targetValue,
  }) async {
    final fcmToken = await _getFcmToken();
    if (fcmToken == null) {
      throw Exception('Unable to get device token for notifications');
    }

    final alertData = {
      'fcm_token': fcmToken,
      'rate_type': rateType,
      'condition_type': conditionType,
      'target_value': targetValue,
      'is_active': true,
    };

    developer.log(
      'Creating alert: $rateType $conditionType $targetValue',
      name: 'AlertService',
    );
    developer.log('Sending to: $_baseUrl', name: 'AlertService');
    developer.log('Data: $alertData', name: 'AlertService');

    try {
      final response = await http
          .post(
            Uri.parse(_baseUrl),
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
            },
            body: json.encode(alertData),
          )
          .timeout(const Duration(seconds: 15));

      developer.log(
        'Response status: ${response.statusCode}',
        name: 'AlertService',
      );
      developer.log('Response body: ${response.body}', name: 'AlertService');

      if (response.statusCode == 201) {
        final responseData = json.decode(response.body);
        final alert = RateAlert.fromJson(responseData['alert']);

        developer.log(
          'Created alert successfully: ${alert.rateDisplayName} ${alert.displayCondition} ${alert.targetValue}',
          name: 'AlertService',
        );

        return alert;
      } else {
        final errorData = json.decode(response.body);
        throw Exception(
          errorData['error'] ??
              'Failed to create alert: ${response.statusCode}',
        );
      }
    } on TimeoutException {
      throw Exception('Request timed out. Please try again.');
    } catch (e) {
      developer.log('Error creating alert: $e', name: 'AlertService');
      throw Exception('Failed to create alert: $e');
    }
  }

  Future<List<RateAlert>> getUserAlerts() async {
    final fcmToken = await _getFcmToken();
    if (fcmToken == null) {
      throw Exception('Unable to get device token');
    }

    developer.log(
      'Fetching alerts for token: ${fcmToken.substring(0, 20)}...',
      name: 'AlertService',
    );

    try {
      final response = await http
          .get(
            Uri.parse('$_baseUrl/$fcmToken'),
            headers: {'Accept': 'application/json'},
          )
          .timeout(const Duration(seconds: 15));

      developer.log(
        'Fetch response status: ${response.statusCode}',
        name: 'AlertService',
      );
      developer.log(
        'Fetch response body: ${response.body}',
        name: 'AlertService',
      );

      if (response.statusCode == 200) {
        final responseData = json.decode(response.body);
        final alertsJson = responseData['alerts'] as List;
        final alerts = alertsJson
            .map((json) => RateAlert.fromJson(json))
            .toList();

        developer.log(
          'Loaded ${alerts.length} alerts from server',
          name: 'AlertService',
        );
        return alerts;
      } else {
        final errorData = json.decode(response.body);
        throw Exception(
          errorData['error'] ??
              'Failed to fetch alerts: ${response.statusCode}',
        );
      }
    } on TimeoutException {
      throw Exception('Request timed out. Please try again.');
    } catch (e) {
      developer.log('Error fetching alerts: $e', name: 'AlertService');
      throw Exception('Failed to fetch alerts: $e');
    }
  }

  Future<void> deleteAlert(String alertId) async {
    developer.log('Deleting alert: $alertId', name: 'AlertService');

    try {
      final response = await http
          .delete(
            Uri.parse('$_baseUrl/$alertId'),
            headers: {'Accept': 'application/json'},
          )
          .timeout(const Duration(seconds: 15));

      developer.log(
        'Delete response status: ${response.statusCode}',
        name: 'AlertService',
      );

      if (response.statusCode == 200) {
        developer.log(
          'Deleted alert successfully: $alertId',
          name: 'AlertService',
        );
      } else {
        final errorData = json.decode(response.body);
        throw Exception(
          errorData['error'] ??
              'Failed to delete alert: ${response.statusCode}',
        );
      }
    } on TimeoutException {
      throw Exception('Request timed out. Please try again.');
    } catch (e) {
      developer.log('Error deleting alert: $e', name: 'AlertService');
      throw Exception('Failed to delete alert: $e');
    }
  }

  Future<void> updateAlert(String alertId, {bool? isActive}) async {
    if (isActive == null) return;

    final updateData = {'is_active': isActive};

    developer.log(
      'Updating alert $alertId to ${isActive ? "active" : "inactive"}',
      name: 'AlertService',
    );

    try {
      final response = await http
          .patch(
            Uri.parse('$_baseUrl/$alertId'),
            headers: {
              'Content-Type': 'application/json',
              'Accept': 'application/json',
            },
            body: json.encode(updateData),
          )
          .timeout(const Duration(seconds: 15));

      developer.log(
        'Update response status: ${response.statusCode}',
        name: 'AlertService',
      );

      if (response.statusCode == 200) {
        developer.log(
          'Updated alert successfully: $alertId',
          name: 'AlertService',
        );
      } else {
        final errorData = json.decode(response.body);
        throw Exception(
          errorData['error'] ??
              'Failed to update alert: ${response.statusCode}',
        );
      }
    } on TimeoutException {
      throw Exception('Request timed out. Please try again.');
    } catch (e) {
      developer.log('Error updating alert: $e', name: 'AlertService');
      throw Exception('Failed to update alert: $e');
    }
  }

  Future<void> clearAllAlerts() async {
    final fcmToken = await _getFcmToken();
    if (fcmToken == null) {
      throw Exception('Unable to get device token');
    }

    developer.log('Clearing all alerts for device', name: 'AlertService');

    try {
      final alerts = await getUserAlerts();

      for (final alert in alerts) {
        await deleteAlert(alert.id);
      }

      developer.log('Cleared all alerts successfully', name: 'AlertService');
    } catch (e) {
      developer.log('Error clearing alerts: $e', name: 'AlertService');
      throw Exception('Failed to clear alerts: $e');
    }
  }

  Future<void> refreshFcmToken() async {
    try {
      await _firebaseMessaging.deleteToken();
      final newToken = await _firebaseMessaging.getToken();
      developer.log(
        'FCM token refreshed: ${newToken?.substring(0, 20)}...',
        name: 'AlertService',
      );
    } catch (e) {
      developer.log('Error refreshing FCM token: $e', name: 'AlertService');
    }
  }

  Future<bool> testConnection() async {
    try {
      final healthUrl = _baseUrl.replaceAll('/alerts', '/health');
      final response = await http
          .get(Uri.parse(healthUrl), headers: {'Accept': 'application/json'})
          .timeout(const Duration(seconds: 10));

      developer.log(
        'Backend health check: ${response.statusCode}',
        name: 'AlertService',
      );
      developer.log('Backend response: ${response.body}', name: 'AlertService');

      return response.statusCode == 200;
    } catch (e) {
      developer.log('Backend connection test failed: $e', name: 'AlertService');
      return false;
    }
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\services\api_service.dart
Content:
import 'dart:async'; // Import the async library for TimeoutException
import 'dart:convert';
import 'package:http/http.dart' as http;

class ApiService {
  final String _liveApiUrl = "https://goldrate.divyanshbansal.com/api/live";
  final String _graphApiBaseUrl =
      "https://goldrate.divyanshbansal.com/api/rates";

  Future<Map<String, dynamic>> fetchLiveRates() async {
    final url = Uri.parse(_liveApiUrl);
    try {
      // We will now give the request 20 seconds to complete before timing out.
      final response = await http.get(
        url,
        headers: {'Accept': 'application/json'},
      ).timeout(const Duration(seconds: 20)); // Added timeout

      if (response.statusCode == 200) {
        return json.decode(response.body) as Map<String, dynamic>;
      } else {
        throw Exception(
          'Failed to load live rates. Status code: ${response.statusCode}',
        );
      }
    } on TimeoutException {
      // This will be thrown if the server doesn't respond in 20 seconds.
      throw Exception('The connection to the server timed out.');
    } catch (e) {
      // Catches other errors, like no internet connection.
      throw Exception('Failed to connect to the server. Error: $e');
    }
  }

  Future<Map<String, dynamic>> fetchGraphData(
    String series,
    String queryParams,
  ) async {
    final url = Uri.parse('$_graphApiBaseUrl$queryParams');
    try {
      // Also adding a timeout to the graph data request for consistency.
      final response = await http.get(
        url,
        headers: {'Accept': 'application/json'},
      ).timeout(const Duration(seconds: 20)); // Added timeout

      if (response.statusCode == 200) {
        return json.decode(response.body) as Map<String, dynamic>;
      } else {
        throw Exception(
          'Failed to load graph data. Status code: ${response.statusCode}',
        );
      }
    } on TimeoutException {
      throw Exception('The connection to the server timed out.');
    } catch (e) {
      throw Exception('Failed to connect to the server. Error: $e');
    }
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\services\notification_service.dart
Content:
import 'package:firebase_messaging/firebase_messaging.dart';
import 'dart:developer' as developer;

class NotificationService {
  final _firebaseMessaging = FirebaseMessaging.instance;
  String? _currentFcmToken;

  String? get currentFcmToken => _currentFcmToken;

  Future<void> initNotifications() async {
    await _requestPermissions();
    await _getFcmToken();
    _setupMessageHandling();
  }

  Future<void> _requestPermissions() async {
    final settings = await _firebaseMessaging.requestPermission(
      alert: true,
      badge: true,
      sound: true,
      provisional: false,
    );

    if (settings.authorizationStatus == AuthorizationStatus.denied) {
      developer.log('User denied notification permissions', name: 'NotificationService');
    } else {
      developer.log('Notification permissions granted', name: 'NotificationService');
    }
  }

  Future<void> _getFcmToken() async {
    try {
      _currentFcmToken = await _firebaseMessaging.getToken();
      developer.log('FCM Token: $_currentFcmToken', name: 'NotificationService');

      _firebaseMessaging.onTokenRefresh.listen((newToken) {
        _currentFcmToken = newToken;
        developer.log('FCM Token refreshed: $newToken', name: 'NotificationService');
      });
    } catch (e) {
      developer.log('Error getting FCM token: $e', name: 'NotificationService');
    }
  }

  void _setupMessageHandling() {
    FirebaseMessaging.onMessage.listen((RemoteMessage message) {
      developer.log('Received foreground message: ${message.messageId}', name: 'NotificationService');
      
      if (message.notification != null) {
        developer.log(
          'Notification: ${message.notification!.title} - ${message.notification!.body}',
          name: 'NotificationService'
        );
      }
    });

    FirebaseMessaging.onMessageOpenedApp.listen((RemoteMessage message) {
      developer.log('Notification tapped - opened app: ${message.messageId}', name: 'NotificationService');
      _handleNotificationTap(message);
    });

    _firebaseMessaging.getInitialMessage().then((RemoteMessage? message) {
      if (message != null) {
        developer.log('App launched from notification: ${message.messageId}', name: 'NotificationService');
        _handleNotificationTap(message);
      }
    });
  }

  void _handleNotificationTap(RemoteMessage message) {
    final data = message.data;
    
    if (data.containsKey('alert_type') && data['alert_type'] == 'rate_alert') {
      final rateType = data['rate_type'];
      final targetValue = data['target_value'];
      final conditionType = data['condition_type'];
      
      developer.log(
        'Rate alert notification tapped - Rate: $rateType, Target: $targetValue, Condition: $conditionType',
        name: 'NotificationService'
      );
    }
  }

  Future<String?> refreshToken() async {
    try {
      await _firebaseMessaging.deleteToken();
      _currentFcmToken = await _firebaseMessaging.getToken();
      developer.log('FCM token refreshed: $_currentFcmToken', name: 'NotificationService');
      return _currentFcmToken;
    } catch (e) {
      developer.log('Error refreshing FCM token: $e', name: 'NotificationService');
      return null;
    }
  }
}

@pragma('vm:entry-point')
Future<void> firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  developer.log('Background message received: ${message.messageId}', name: 'BackgroundHandler');
}

Path: C:\MyData\Flutter\flutter_application_1\lib\widgets\cool_loader.dart
Content:
import 'package:flutter/material.dart';
import 'dart:math' as math;

class CoolLoader extends StatefulWidget {
  final String? loadingText;
  final Color? primaryColor;
  final double size;

  const CoolLoader({
    super.key,
    this.loadingText,
    this.primaryColor,
    this.size = 120.0,
  });

  @override
  State<CoolLoader> createState() => _CoolLoaderState();
}

class _CoolLoaderState extends State<CoolLoader> with TickerProviderStateMixin {
  late AnimationController _rotationController;
  late AnimationController _fadeController;
  late Animation<double> _rotationAnimation;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();

    _rotationController = AnimationController(
      duration: const Duration(seconds: 2),
      vsync: this,
    );
    _rotationAnimation = Tween<double>(begin: 0, end: 2 * math.pi).animate(
      CurvedAnimation(parent: _rotationController, curve: Curves.easeInOut),
    );

    _fadeController = AnimationController(
      duration: const Duration(milliseconds: 1500),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.4, end: 1.0).animate(
      CurvedAnimation(parent: _fadeController, curve: Curves.easeInOut),
    );

    _rotationController.repeat();
    _fadeController.repeat(reverse: true);
  }

  @override
  void dispose() {
    _rotationController.dispose();
    _fadeController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final primaryColor =
        widget.primaryColor ?? Theme.of(context).colorScheme.primary;
    final onPrimary = Theme.of(context).colorScheme.onPrimary;

    return Column(
      mainAxisAlignment: MainAxisAlignment.center,
      children: [
        SizedBox(
          width: widget.size,
          height: widget.size,
          child: Stack(
            alignment: Alignment.center,
            children: [
              // Outer circle
              Container(
                width: widget.size,
                height: widget.size,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: primaryColor.withOpacity(0.1),
                ),
              ),

              // Rotating arcs
              AnimatedBuilder(
                animation: _rotationAnimation,
                builder: (context, child) {
                  return Transform.rotate(
                    angle: _rotationAnimation.value,
                    child: CustomPaint(
                      size: Size(widget.size * 0.8, widget.size * 0.8),
                      painter: LoaderPainter(
                        color: primaryColor,
                        progress: _rotationAnimation.value,
                      ),
                    ),
                  );
                },
              ),

              // Center content
              AnimatedBuilder(
                animation: _fadeAnimation,
                builder: (context, child) {
                  return Opacity(
                    opacity: _fadeAnimation.value,
                    child: Container(
                      width: widget.size * 0.4,
                      height: widget.size * 0.4,
                      decoration: BoxDecoration(
                        shape: BoxShape.circle,
                        color: primaryColor,
                        boxShadow: [
                          BoxShadow(
                            color: primaryColor.withOpacity(0.3),
                            blurRadius: 8,
                            spreadRadius: 2,
                          ),
                        ],
                      ),
                      child: Icon(
                        Icons.trending_up,
                        color: onPrimary,
                        size: 24,
                      ),
                    ),
                  );
                },
              ),
            ],
          ),
        ),

        const SizedBox(height: 32),

        // Loading text
        AnimatedBuilder(
          animation: _fadeAnimation,
          builder: (context, child) {
            return Opacity(
              opacity: _fadeAnimation.value,
              child: Text(
                widget.loadingText ?? 'Loading GC Gold Rates...',
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w500,
                  letterSpacing: 0.3,
                ),
                textAlign: TextAlign.center,
              ),
            );
          },
        ),

        const SizedBox(height: 8),

        // Progress dots
        _buildProgressDots(primaryColor),
      ],
    );
  }

  Widget _buildProgressDots(Color primaryColor) {
    return AnimatedBuilder(
      animation: _rotationController,
      builder: (context, child) {
        return Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: List.generate(3, (index) {
            final delay = index * 0.3;
            final progress = (_rotationController.value + delay) % 1.0;
            final opacity = (math.sin(progress * 2 * math.pi) + 1) / 2;

            return Container(
              margin: const EdgeInsets.symmetric(horizontal: 3),
              width: 6,
              height: 6,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: primaryColor.withOpacity(0.3 + opacity * 0.7),
              ),
            );
          }),
        );
      },
    );
  }
}

class LoaderPainter extends CustomPainter {
  final Color color;
  final double progress;

  LoaderPainter({required this.color, required this.progress});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 3.0
      ..strokeCap = StrokeCap.round
      ..style = PaintingStyle.stroke;

    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2 - 4;

    // Draw multiple arcs
    for (int i = 0; i < 3; i++) {
      final startAngle = (progress * 2 * math.pi) + (i * 2 * math.pi / 3);
      final sweepAngle = math.pi / 2;
      final opacity = 1.0 - (i * 0.3);

      paint.color = color.withOpacity(opacity);

      canvas.drawArc(
        Rect.fromCircle(center: center, radius: radius - (i * 8)),
        startAngle,
        sweepAngle,
        false,
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(LoaderPainter oldDelegate) {
    return oldDelegate.progress != progress;
  }
}


Path: C:\MyData\Flutter\flutter_application_1\lib\widgets\rate_card.dart
Content:
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import '../models/rate_card.dart' as model;
import '../screens/main_screen.dart';

class RateCardWidget extends StatelessWidget {
  final model.RateCard card;
  const RateCardWidget({Key? key, required this.card}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final currencyFormatter = NumberFormat.currency(
      locale: 'en_IN',
      symbol: '₹ ',
      decimalDigits: 2,
    );
    final changeFormatter = NumberFormat('+#;-#', 'en_IN');
    final colors = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    final currentBuy = double.tryParse(card.buyRate) ?? 0;
    final prevBuy = double.tryParse(card.previousBuyRate) ?? 0;
    final buyChange = currentBuy - prevBuy;
    final buyColor = buyChange == 0
        ? colors.onSurfaceVariant
        : (buyChange > 0 ? Colors.green : colors.error);
    final buyIcon = buyChange == 0
        ? Icons.remove
        : (buyChange > 0 ? Icons.arrow_upward : Icons.arrow_downward);

    final currentSell = double.tryParse(card.sellRate) ?? 0;
    final prevSell = double.tryParse(card.previousSellRate) ?? 0;
    final sellChange = currentSell - prevSell;
    final sellColor = sellChange == 0
        ? colors.onSurfaceVariant
        : (sellChange > 0 ? Colors.green : colors.error);
    final sellIcon = sellChange == 0
        ? Icons.remove
        : (sellChange > 0 ? Icons.arrow_upward : Icons.arrow_downward);

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8, horizontal: 8),
      elevation: 3,
      clipBehavior: Clip.antiAlias,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(color: colors.outline, width: 1),
      ),
      child: InkWell(
        onTap: () {
          final mainState = context.findAncestorStateOfType<MainScreenState>();
          if (mainState != null) {
            mainState.switchToChartsTab(card.apiSymbol);
          }
        },
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
              color: colors.primaryContainer,
              child: Text(
                card.title,
                style: textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: colors.onPrimaryContainer,
                ),
                textAlign: TextAlign.center,
              ),
            ),
            IntrinsicHeight(
              child: Row(
                children: [
                  Expanded(
                    child: _buildRateColumn(
                      label: 'BUY',
                      amount: currentBuy,
                      change: buyChange,
                      color: buyColor,
                      icon: buyIcon,
                      high: double.tryParse(card.buyHigh) ?? 0,
                      low: double.tryParse(card.buyLow) ?? 0,
                      currencyFormatter: currencyFormatter,
                      changeFormatter: changeFormatter,
                      textTheme: textTheme,
                      colors: colors,
                    ),
                  ),
                  VerticalDivider(
                    color: colors.outline,
                    width: 1,
                    thickness: 1,
                  ),
                  Expanded(
                    child: _buildRateColumn(
                      label: 'SELL',
                      amount: currentSell,
                      change: sellChange,
                      color: sellColor,
                      icon: sellIcon,
                      high: double.tryParse(card.sellHigh) ?? 0,
                      low: double.tryParse(card.sellLow) ?? 0,
                      currencyFormatter: currencyFormatter,
                      changeFormatter: changeFormatter,
                      textTheme: textTheme,
                      colors: colors,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildRateColumn({
    required String label,
    required double amount,
    required double change,
    required Color color,
    required IconData icon,
    required double high,
    required double low,
    required NumberFormat currencyFormatter,
    required NumberFormat changeFormatter,
    required TextTheme textTheme,
    required ColorScheme colors,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 8),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            label,
            style: textTheme.bodyMedium?.copyWith(
              color: colors.onSurfaceVariant,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          Text(
            currencyFormatter.format(amount),
            style: textTheme.headlineSmall?.copyWith(
              fontWeight: FontWeight.bold,
              color: color,
            ),
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 4),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(icon, color: color, size: 16),
              const SizedBox(width: 4),
              Text(
                changeFormatter.format(change),
                style: textTheme.bodyMedium?.copyWith(
                  color: color,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          _buildHighLow(
            'High',
            high,
            currencyFormatter,
            textTheme,
            Colors.green,
            colors.onSurfaceVariant,
          ),
          const SizedBox(height: 4),
          _buildHighLow(
            'Low',
            low,
            currencyFormatter,
            textTheme,
            colors.error,
            colors.onSurfaceVariant,
          ),
        ],
      ),
    );
  }

  Widget _buildHighLow(
    String label,
    double value,
    NumberFormat formatter,
    TextTheme textTheme,
    Color color,
    Color onSurfaceVariant,
  ) {
    return RichText(
      textAlign: TextAlign.center,
      text: TextSpan(
        style: textTheme.bodySmall?.copyWith(color: onSurfaceVariant),
        children: [
          TextSpan(text: '$label: '),
          TextSpan(
            text: formatter.format(value),
            style: textTheme.bodySmall?.copyWith(
              fontWeight: FontWeight.w600,
              color: color,
            ),
          ),
        ],
      ),
    );
  }
}



